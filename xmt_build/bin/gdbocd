#!/usr/bin/env perl
#************************************************************************
#   $Version:$
#   Package	: 
#   Synopsis	: gdbgui <pgm.elf>
#   Purpose	: spawn openocd, launch gdbgui, connect to target, debug <pgm.elf>.
#
#   Copyright 2018 Visionary Research Inc.  
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License. 
#************************************************************************

$SIG{INT} 	= \&cleanup;
$SIG{TERM}	= \&cleanup;
use Env;

# note: when executing on Windows gdbgui needs a Windows-style path to gdb
my $gdb		= "$GCCROOT/bin/arm-none-eabi-gdb";
my $gdb_args	= "--quiet " 
		. "-ex 'target remote :3333' "	# openocd's gdbserver port
		. "-ex 'monitor reset halt' "	# halt ARM's execution
		. "-ex 'monitor reset init' "	# reset pgm counter to start
		. "-ex 'monitor arm semihosting enable' " # enable semihosting
		. "-ex 'break main' "		# break at first instruction of main
		. "-ex 'load' "			# force reflash to board
		. "-ex 'continue' ";		# run to break at main

my $gdbgui	= "$ENV{'HOME'}/.local/bin/gdbgui";
my $gdbgui_args	= "-g $gdb --gdb-args=\"$gdb_args\"";

# note: openocd needs a Windows-style path to its config file
my $openocd	= `which openocd`; chomp $openocd;
my $ocd_args	= "/usr/share/openocd/scripts/board/st_nucleo_l476rg.cfg";

# launch openocd & leave running as a background process
system( "$openocd -f $ocd_args 1>/dev/null 2>&1 &" );

# launch gdbgui, it spawns gdb, gdb connects to openocd ...
# then gdb reads its startup commands.
system( "$gdbgui $gdbgui_args --args $ARGV[0]") or die "$gdbgui: $!\n";

END {
    cleanup();
}

sub cleanup
{
    print "killing child processes...\n";
    system("pkill --echo --full $openocd	> /dev/null 2>&1");
    system("pkill --echo --full $gdb		> /dev/null 2>&1");
    system("pkill --echo --full $gdbgui		> /dev/null 2>&1");
}
