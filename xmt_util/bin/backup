#!/usr/bin/env perl 
#************************************************************************
#   Package	: xmt_util
#  usage: backup [--full] [--dest=<dstpath>] srcpath 
#  rsync the specified path tree to the defined destination.
#  If --full is specified. perform a deep copy of srcpath to dstpath.
#  If --full is NOT specified. perform a skinny copy of the last .0 to dstpath
#  			  then perform a skinny copy of srcpath to dstpath.
#  This results in a new incremental backup of srcpath with today's date.
#  In all cases we exclude files matching patterns specified in ./backup.exclude
#  Log output to /var/logs/backup.log
#
#  Backups are host and date-stamped, rather than just being level-stamped
#  (i.e.  /Backups/M6800.home.0.2019-11-01   rather than just Backups/home.0)
#  This allows us to keep multiple full backups 
#  and multiple incrementals (hard linked copies) from each of the full backups.
#  eg:      backup  --full /home 	
#  creates a full backup of /home, dated today. Does not touch any previous backups.
#  while:   backup  /home 	
#  creates a copy of the previous home.0 named home.1 containing only hard links, 
#  then rsync's srcpath to home.1
#  
#  The result is that we get an unlimited number of incremental backups from 
#  an unlimited number of full backups.
#  Here is an example crontab:
#	@weekly		backup --full /home
#	@daily		backup /home
#
#  Deleting of old backups is easily done with a find command:
#	@monthly  find /Backups -maxdepth 0 -ctime 365 -delete   # delete backups over 1yr old
#
#    Copyright 2019 Visionary Research Inc.   All rights reserved.
#    			legal@visionary-research.com
#*  Licensed under the Apache License, Version 2.0 (the "License");
#*  you may not use this file except in compliance with the License.
#*  You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#*  
#*  Unless required by applicable law or agreed to in writing, software
#*  distributed under the License is distributed on an "AS IS" BASIS,
#*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#*  See the License for the specific language governing permissions and
#*  limitations under the License. 
#************************************************************************

use strict;
use Getopt::Long;
use File::Basename;
use POSIX qw(strftime tzset);
use Env;

(my $pgmname = $0) =~ s{.*/}{};
my $usage	= "usage: $pgmname [-u] [--full] [--dest=<path>] <path>\n";
my $logfile	= "/var/log/backup.log";
my $excludes	= "$0.exclude";				# search in same directory as pgm
my $hostname	=`/bin/hostname`; chomp($hostname);
my $dstroot	= "/cygdrive/c/Backups/$hostname";	# unless overridden by --dest
$ENV{'TZ'}	= "America/Vancouver"; tzset();		# necessary for Windows OS

##   there's nothing configurable below this line.  Leave it alone.
our ($opt_u,  $opt_f);
$opt_f = 0;
GetOptions( "u" => \$opt_u, "dest=s" => \$dstroot, "full|f|0!" => \$opt_f ) or die $usage;
die "$usage" if defined $opt_u;
my $srcpath = $ARGV[$#ARGV]	or die $usage;
$srcpath =~ s:/$::;		# strip trailing slash
open(my $LOG, ">>", $logfile) or die "$logfile: $!";
$LOG->autoflush(1); 

my ($basename, $path, $sfx)	= fileparse($srcpath);
my $today = strftime("%F", localtime);
my @lasts = glob( "$dstroot/$hostname.$basename.0.*"); 
$opt_f = 1 if ($#lasts eq -1); 	# revert to full backup if no previous one exists

# log the start of the backup with a timestamp
my $timenow = strftime("%X", localtime);
print $LOG "\n\n______________________________________________________________\n";
print $LOG ($opt_f ? "full " : "skinny") . "backup of $srcpath started $today at $timenow \n";

# if this is a full backup, perform a deep copy of srcpath to (non-existing) dstpath.
if ($opt_f)
{
    my $dstpath = "$dstroot/$hostname.$basename.0." . $today;
    skinny_copy($srcpath, $dstpath, $excludes);
}
else # this a skinny backup based on a previous full backup
{
    # create a hardlink copy of the last full backup to non-existing dstpath, 
    # then perform a skinny copy from srcpath to the now existing dstpath.
    my $dstpath = "$dstroot/$hostname.$basename.1." . $today;
    system("cp -al $lasts[0]  $dstpath");
    skinny_copy($srcpath, $dstpath, $excludes);
}
exit 0;


sub skinny_copy
{
    my ($srcpath, $dstpath, $excludes) = @_;
    
    ###  WINDOWS HACK:  cygwin rsync doesn't recognize symlinks, 
    ###  so manually find all symlinks under $srcpath and add to $excludes.
    ###  rsync --no-links won't work because it doesn't recognize the links as links.
    my $os  = `/bin/uname`;
    if ($os =~ /CYGWIN/) 
    {
	my $tmpexcludes = "/tmp/backup.exclude";
	print $LOG "scan $srcpath for symlinks\n";
	system("cp $excludes $tmpexcludes");
	system("cd $srcpath && find . -type l -print | sed -e 's:^\.::' -e 's: :\\ :' >>$tmpexcludes");
	$excludes = $tmpexcludes;
    }

    my $cmd = "rsync --archive --delete --one-file-system  --stats --human-readable";
    $cmd .= " --exclude-from=$excludes" if (-e $excludes);
    $cmd .= " $srcpath/ $dstpath";
    print $LOG "$cmd \n";
    system("$cmd >>$logfile 2>&1");
    my $timenow = strftime("%X", localtime);
    print $LOG "... ended at $timenow \n";
}
