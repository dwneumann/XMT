#!/usr/bin/env perl 
#************************************************************************
#   Package	: xmt_util
#  usage: backup -[0|1] [--dest=<dstpath>] srcpath 
#  Create a tar archive of the specified srcpath to the specified dstpath.
#  If -0 is specified a level 0 archive is created.
#  If -1 is specified an incremental archive is created consisting of files
#  	newer than the timestamp of the last level 0 found in the <dstpath> directory.
#  In all cases we exclude files matching regex patterns specified in ./backup.exclude
#  In all cases we write a manifest of the contents of the tar archive in the same
#  directory as the archive.
#  The command is logged to /var/logs/backup.log
#
#  Backups are host, level and date-stamped
#  i.e.  /Backups/M6800.home.2019-11-01.0.tgz
#  	 /Backups/M6800.home.2019-11-01.0.manifest
#  
#  Here is an example crontab:
#	@weekly		backup -0 /home
#	@daily		backup -1 /home
#
#  Deleting of old backups is easily done with a find command:
#	@monthly  find /Backups -maxdepth 0 -ctime 365 -delete   # delete backups over 1yr old
#
#    Copyright 2019 Visionary Research Inc.   All rights reserved.
#    			legal@visionary-research.com
#*  Licensed under the Apache License, Version 2.0 (the "License");
#*  you may not use this file except in compliance with the License.
#*  You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#*  
#*  Unless required by applicable law or agreed to in writing, software
#*  distributed under the License is distributed on an "AS IS" BASIS,
#*  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#*  See the License for the specific language governing permissions and
#*  limitations under the License. 
#************************************************************************

use strict;
use Getopt::Long;
use File::Basename;
use File::Find::Rule;
use POSIX qw(strftime tzset);
use Env;

(my $pgmname = $0) =~ s{.*/}{};
my $usage	= "usage: $pgmname [-u] [-0|1] [--dest=<path>] <path>\n";
my $logfile	= "/var/log/backup.log";
my $excludes	= "$0.exclude";			# search in same directory as pgm
my $hostname	=`/bin/hostname`; chomp($hostname);
my $dstroot	= "/c/Backups/$hostname";	# unless overridden by --dest
$ENV{'TZ'}	= "America/Vancouver"; tzset();		# necessary for Windows OS
my $today 	= strftime("%F", localtime);

##   there's nothing configurable below this line.  Leave it alone.
my ($opt_u, $opt_full, $opt_incr);
GetOptions( "u" => \$opt_u, "dest=s" => \$dstroot, 
	    "0" => \$opt_full, "1" => \$opt_incr ) or die $usage;
die "$usage" if defined $opt_u;
my $level = (defined $opt_incr ? 1: 0);
my $srcpath = $ARGV[$#ARGV]	or die $usage;
$srcpath =~ s:/$::;		# strip trailing slash
open(my $LOG, ">>", $logfile) or die "$logfile: $!";
$LOG->autoflush(1); 

my ($basename, $path, $sfx)	= fileparse($srcpath);
print $LOG "\n\n______________________________________________________________\n";
timestamp($LOG, "level $level backup of $srcpath started");

# find most recent level 0 
# convert to level 0 if this is level 1 but there's no last level 0
my @fullbackups = glob( "$dstroot/$hostname.$basename.*.0.tgz");
my $last0 = $fullbackups[$#fullbackups];
if (! -e $last0)
{
    $level = 0;
    print $LOG "no previous level 0 found.  Reverting to level 0 backup\n";
}

my $last0_mtime = (stat($last0))[9] if ($level > 0);
my $dstpath = "$dstroot/$hostname.$basename.$today.$level";
my $manifest = "$dstpath.manifest";
create_manifest($srcpath, $excludes, $manifest, $last0);
backup($srcpath, $dstpath, $manifest);
timestamp($LOG, "level $level backup of $srcpath ended successfully");

exit 0;


sub timestamp
{
    my ($LOG, $str) = @_;
    my $timenow = strftime("%F %X", localtime);
    print $LOG "$timenow: $str \n";
}

sub create_manifest
{
    my ($srcpath, $excludes, $manifest, $last0) = @_;

    # read all exclude patterns into array
    open my $fh, '<', $excludes or die "$excludes: $!";
    chomp(my @exclude_ptns = <$fh>);	
    close $fh;

    # create list of all files in srcpath, then exclude all that match any excluded pattern
    my $rule  = File::Find::Rule->new; 
    my @files = $rule->in($srcpath);	
    for my $ptn (@exclude_ptns)
    {
        @files = grep { $_ !~ m/$ptn/ } @files;
    }

    open $fh, '>', $manifest or die "$manifest: $!";
    for (@files)
    {
	next if (! -f $_);
	# add filename to manifest if level0 or if mtime is later than last0_mtime
	my $this_mtime = (stat($_))[9];		
	$_ =~ s{$srcpath}{.};
	print $fh "$_\n" if ($level==0 || ($last0_mtime > 0 && $this_mtime > $last0_mtime));
    }
    close $fh;
}

sub backup
{
    my ($srcpath, $dstpath, $manifest) = @_;
    
    my $cmd = "tar --create --file=$dstpath.tgz --directory=$srcpath ";
    $cmd .= " --use-compress-program=pigz";
    $cmd .= " --ignore-failed-read --exclude-backups --seek --totals";
    $cmd .= " --record-size=65536 --checkpoint=163840";  # 64KB writes, 10GB checkpoints
    $cmd .= " --checkpoint-action=totals";
    $cmd .= " --files-from=$manifest";
    print $LOG "$cmd \n";
    system("$cmd >>$logfile 2>&1") == 0 or die "$cmd: failed with: $!";
}
