#!/usr/bin/env perl
#************************************************************************
#   $Version:$
#   Package	: 
#   Synopsis	: gdbocd <pgm.elf>
#   Purpose	: spawn openocd, launch gdbgui, connect to target, debug <pgm.elf>.
#
#   Copyright 2018 Visionary Research Inc.  
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0
#   
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License. 
#************************************************************************

use strict;
use Getopt::Long;
use File::Basename;
$SIG{INT} 	= \&cleanup;
$SIG{TERM}	= \&cleanup;
use Env;

(my $pgmname = $0) =~ s{.*/}{};
my $usage = "$pgmname [-nogui] -b[oard] <board_name> <pgm.elf>";
undef my $opt_u;	# unnecessary, but it shuts up -w
undef my $nogui;	# unnecessary, but it shuts up -w
my $board = 'st.*[fl]4.*';	# by default, filter the options to just STM32 boards
GetOptions( "board=s"  => \$board, "nogui" => \$nogui, "u" ) || die $usage;
die "$usage" if defined $opt_u;
my $elf = $ARGV[0];

# note: when executing on Windows gdbgui needs a Windows-style path to gdb
my $gdb		= "$GCCROOT/bin/arm-none-eabi-gdb";
my $gdb_args	= "--quiet " 
		. "-ex 'target remote :3333' "	# openocd's gdbserver port
		. "-ex 'monitor reset halt' "	# halt ARM's execution
		. "-ex 'monitor reset init' "	# reset pgm counter to start
		. "-ex 'monitor arm semihosting enable' " # enable semihosting
		. "-ex 'break main' "		# break at first instruction of main
		. "-ex 'load' "			# force reflash to board
		. "-ex 'continue' ";		# run to break at main

my $gdbgui	= "$ENV{'HOME'}/.local/bin/gdbgui";
my $gdb_cmd	= "$gdb $gdb_args";
my $gdbgui_args	= "-g $gdb --gdb-args=\"$gdb_args\"";

# note: when executing on Windows openocd needs a Windows-style path to its config file
my $openocd	= `which openocd`; chomp $openocd;
my $ocd_args	= get_board_selection($board);

# launch openocd & leave running as a background process
system( "$openocd -f $ocd_args 1>/dev/null 2>&1 &" );

if (defined $nogui)
{
    system( "$gdb_cmd $elf") or die "$gdb: $!\n";
}
else
{
    # launch gdbgui, it spawns gdb, gdb connects to openocd ...
    # then gdb reads its startup commands.
    system( "$gdbgui $gdbgui_args --args $elf") or die "$gdbgui: $!\n";
}

END {
    cleanup();
}

sub get_board_selection
{
    my $cfg_dir	= "/usr/share/openocd/scripts/board";
    my ($pattern) = @_;

    my @matching_boards =  sort grep( /${pattern}/i, glob qq("${cfg_dir}/*.cfg"));
    die "no boards matching *${pattern}* found" if (scalar(@matching_boards) == 0);
    return $matching_boards[0] if (scalar(@matching_boards) == 1);

    foreach my $i ( 0 .. scalar(@matching_boards) -1)
    {
        printf("[%d]\t%s\n", $i, basename($matching_boards[$i], '.cfg'));
    }
    printf("Which one?: ");
    $| = 1; 		# flush our print
    $_ = <STDIN>;	# read user's input
    die "invalid choice" if ($_ > scalar(@matching_boards));
    return $matching_boards[$_];
}

sub cleanup
{
    print "killing child processes...\n";
    system("pkill --echo --full $openocd	> /dev/null 2>&1");
    system("pkill --echo --full $gdb		> /dev/null 2>&1");
    system("pkill --echo --full $gdbgui		> /dev/null 2>&1");
}
